<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>
    <!-- Test 1: Different x-data syntax styles -->

    <!-- Object literal with different quote styles -->
    <div x-data='{ singleQuote: "value", count: 0 }'>
        <p x-text="singleQuote"></p>
        <p x-text="count"></p>
    </div>

    <div x-data="{ doubleQuote: 'value', enabled: true }">
        <p x-text="doubleQuote"></p>
        <p x-text="enabled"></p>
    </div>

    <!-- Arrow function syntax variations -->
    <div x-data="() => ({ arrowFunc: 'test', num: 42 })">
        <p x-text="arrowFunc"></p>
        <p x-text="num"></p>
    </div>

    <div x-data="() => {
        return {
            multiLine: 'arrow',
            value: 100,
            method() {
                return this.value * 2
            }
        }
    }">
        <p x-text="multiLine"></p>
        <p x-text="method()"></p>
    </div>

    <!-- Test 2: Different method syntax -->
    <div x-data="{
        // Shorthand method syntax
        shortMethod() {
            return 'short'
        },

        // Traditional function syntax
        traditionalMethod: function() {
            return 'traditional'
        },

        // Arrow function property
        arrowMethod: () => {
            return 'arrow'
        },

        // Arrow function inline
        inlineArrow: () => 'inline',

        // Async methods
        async asyncMethod() {
            return await Promise.resolve('async')
        },

        // Generator function
        *generatorMethod() {
            yield 'gen1'
            yield 'gen2'
        }
    }">
        <p x-text="shortMethod()"></p>
        <p x-text="traditionalMethod()"></p>
        <p x-text="arrowMethod()"></p>
        <p x-text="inlineArrow()"></p>
    </div>

    <!-- Test 3: Different property value types -->
    <div x-data="{
        // Primitives
        stringVal: 'text',
        numberVal: 123,
        booleanVal: true,
        nullVal: null,
        undefinedVal: undefined,

        // Template literals
        templateLiteral: `Hello ${1 + 1}`,

        // Computed property names
        ['computed' + 'Key']: 'computed value',

        // Symbols (although Alpine might not handle these well)
        symbolKey: Symbol('test'),

        // BigInt
        bigIntVal: 9007199254740991n,

        // Regular expressions
        regexVal: /test/gi,

        // Dates
        dateVal: new Date(),

        // Maps and Sets
        mapVal: new Map([['key1', 'value1']]),
        setVal: new Set([1, 2, 3])
    }">
        <p x-text="stringVal"></p>
        <p x-text="numberVal"></p>
        <p x-text="booleanVal"></p>
        <p x-text="templateLiteral"></p>
        <p x-text="computedKey"></p>
    </div>

    <!-- Test 4: Complex event handlers -->
    <div x-data="{
        value: 0,
        items: []
    }">
        <!-- Different event syntax -->
        <button x-on:click="value++">@click</button>
        <button x-on:click="value--">x-on:click</button>
        <button @click.prevent="value = 0">Modifier</button>
        <button @click.stop.prevent="value = 100">Multiple modifiers</button>

        <!-- Inline expressions -->
        <button @click="value = value * 2; console.log(value)">Multiple statements</button>
        <button @click="(() => { value = 50; items.push(value) })()">IIFE</button>

        <!-- Complex conditionals -->
        <button @click="value > 10 ? value = 0 : value = 20">Ternary</button>
        <button @click="value && (value = value / 2)">Logical AND</button>
        <button @click="value || (value = 1)">Logical OR</button>
    </div>

    <!-- Test 5: x-for variations -->
    <div x-data="{
        simpleArray: [1, 2, 3],
        objectArray: [{id: 1}, {id: 2}],
        nestedArray: [[1, 2], [3, 4]],
        objectKeys: {a: 1, b: 2, c: 3}
    }">
        <!-- Basic iteration -->
        <template x-for="item in simpleArray">
            <span x-text="item"></span>
        </template>

        <!-- With index -->
        <template x-for="(item, index) in simpleArray" :key="index">
            <span x-text="`${index}: ${item}`"></span>
        </template>

        <!-- Object iteration (Alpine 3.x) -->
        <template x-for="(value, key) in objectKeys" :key="key">
            <span x-text="`${key}: ${value}`"></span>
        </template>

        <!-- Nested template -->
        <template x-for="row in nestedArray">
            <div>
                <template x-for="col in row">
                    <span x-text="col"></span>
                </template>
            </div>
        </template>
    </div>

    <!-- Test 6: Dynamic expressions -->
    <div x-data="{
        dynamicKey: 'test',
        data: {
            test: 'value1',
            other: 'value2'
        },
        items: ['a', 'b', 'c'],
        index: 1
    }">
        <!-- Dynamic property access -->
        <p x-text="data[dynamicKey]"></p>
        <p x-text="items[index]"></p>

        <!-- Dynamic method calls -->
        <p x-text="['to', 'Upper', 'Case'].join('').toLowerCase()"></p>

        <!-- Computed expressions -->
        <p x-text="items.map(x => x.toUpperCase()).join(', ')"></p>
        <p x-text="Object.keys(data).length"></p>
        <p x-text="items.filter(x => x !== 'b').length"></p>
    </div>

    <!-- Test 7: Script function with different patterns -->
    <script>
        // Traditional function declaration
        function traditionalData() {
            return {
                type: 'traditional',
                value: 1
            }
        }

        // Arrow function assignment
        const arrowData = () => ({
            type: 'arrow',
            value: 2
        })

        // Function expression
        const expressionData = function() {
            return {
                type: 'expression',
                value: 3
            }
        }

        // Complex return with getters/setters
        function complexData() {
            let privateValue = 0
            return {
                get value() {
                    return privateValue
                },
                set value(val) {
                    privateValue = val
                },
                increment() {
                    privateValue++
                }
            }
        }
    </script>

    <div x-data="traditionalData()">
        <p x-text="type"></p>
        <p x-text="value"></p>
    </div>

    <div x-data="arrowData()">
        <p x-text="type"></p>
        <p x-text="value"></p>
    </div>

    <div x-data="complexData()">
        <p x-text="value"></p>
        <button @click="increment()">Increment</button>
        <button @click="value = 10">Set to 10</button>
    </div>
</body>
</html>